\hypertarget{class_simple_lexer}{
\section{SimpleLexer Class Reference}
\label{class_simple_lexer}\index{SimpleLexer@{SimpleLexer}}
}
Inheritance diagram for SimpleLexer:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_simple_lexer}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_simple_lexer_ae2bb586444d1d4ce1ef521b9f6b2bc75}{SimpleLexer} (\&\$parser, \$start=\char`\"{}accept\char`\"{}, \$case=false)
\item 
\hyperlink{class_simple_lexer_af0ef334972904054720c4ededafb9a24}{addPattern} (\$pattern, \$mode=\char`\"{}accept\char`\"{})
\item 
\hyperlink{class_simple_lexer_a4fd4c1124a0c5f7b16548351779deab7}{addEntryPattern} (\$pattern, \$mode, \$new\_\-mode)
\item 
\hyperlink{class_simple_lexer_a1cf1b9bc0c1d4b8b3dd465e31a6e1a15}{addExitPattern} (\$pattern, \$mode)
\item 
\hyperlink{class_simple_lexer_a59d5052dc25de99c53042847e8214c4f}{addSpecialPattern} (\$pattern, \$mode, \$special)
\item 
\hyperlink{class_simple_lexer_ad84116197560273d3fd02bd5e74dfe81}{mapHandler} (\$mode, \$handler)
\item 
\hyperlink{class_simple_lexer_afeceabe5e976b20b1e14fed952d79107}{parse} (\$raw)
\item 
\hyperlink{class_simple_lexer_a6dd073c1e7bbc77a4aafd9ac23bba172}{\_\-dispatchTokens} (\$unmatched, \$matched, \$mode=false)
\item 
\hyperlink{class_simple_lexer_a681e5891f263a352e8502f8196b541fc}{\_\-isModeEnd} (\$mode)
\item 
\hyperlink{class_simple_lexer_a419cf4b1b734f60af7a867f352decbd1}{\_\-isSpecialMode} (\$mode)
\item 
\hyperlink{class_simple_lexer_a64f7cbf4238a99aaa177d64dd3614b82}{\_\-decodeSpecial} (\$mode)
\item 
\hyperlink{class_simple_lexer_a287ef4470e221f5b348fbda97a88a70f}{\_\-invokeParser} (\$content, \$is\_\-match)
\item 
\hyperlink{class_simple_lexer_a7d11e9e2b45a5b585b57f82e760b5454}{\_\-reduce} (\$raw)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_simple_lexer_a24815bcf9a657c90be430675208a6953}{
{\bfseries \$\_\-regexes}}
\label{class_simple_lexer_a24815bcf9a657c90be430675208a6953}

\item 
\hypertarget{class_simple_lexer_af133f26ff15129181faf9a7301c512a7}{
{\bfseries \$\_\-parser}}
\label{class_simple_lexer_af133f26ff15129181faf9a7301c512a7}

\item 
\hypertarget{class_simple_lexer_aa274a2329a9a24d6237fbef31e8e22c6}{
{\bfseries \$\_\-mode}}
\label{class_simple_lexer_aa274a2329a9a24d6237fbef31e8e22c6}

\item 
\hypertarget{class_simple_lexer_ae3750c0a0716b7a74bf1fc407339baf5}{
{\bfseries \$\_\-mode\_\-handlers}}
\label{class_simple_lexer_ae3750c0a0716b7a74bf1fc407339baf5}

\item 
\hypertarget{class_simple_lexer_a8ba2ee43e3c73a0b87c0579c803f4529}{
{\bfseries \$\_\-case}}
\label{class_simple_lexer_a8ba2ee43e3c73a0b87c0579c803f4529}

\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{class_simple_lexer_a64f7cbf4238a99aaa177d64dd3614b82}{
\index{SimpleLexer@{SimpleLexer}!\_\-decodeSpecial@{\_\-decodeSpecial}}
\index{\_\-decodeSpecial@{\_\-decodeSpecial}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-decodeSpecial}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-decodeSpecial (
\begin{DoxyParamCaption}
\item[{\$}]{ mode}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a64f7cbf4238a99aaa177d64dd3614b82}
Strips the magic underscore marking single token modes. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$mode} & Mode to decode. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string Underlying mode name.  private 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_a6dd073c1e7bbc77a4aafd9ac23bba172}{
\index{SimpleLexer@{SimpleLexer}!\_\-dispatchTokens@{\_\-dispatchTokens}}
\index{\_\-dispatchTokens@{\_\-dispatchTokens}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-dispatchTokens}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-dispatchTokens (
\begin{DoxyParamCaption}
\item[{\$}]{ unmatched, }
\item[{\$}]{ matched, }
\item[{\$}]{ mode = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a6dd073c1e7bbc77a4aafd9ac23bba172}
Sends the matched token and any leading unmatched text to the parser changing the lexer to a new mode if one is listed. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$unmatched} & Unmatched leading portion. \\
\hline
string & {\em \$matched} & Actual token match. \\
\hline
string & {\em \$mode} & Mode after match. A boolean false mode causes no change. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean False if there was any error from the parser.  private 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_a287ef4470e221f5b348fbda97a88a70f}{
\index{SimpleLexer@{SimpleLexer}!\_\-invokeParser@{\_\-invokeParser}}
\index{\_\-invokeParser@{\_\-invokeParser}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-invokeParser}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-invokeParser (
\begin{DoxyParamCaption}
\item[{\$}]{ content, }
\item[{\$}]{ is\_\-match}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a287ef4470e221f5b348fbda97a88a70f}
Calls the parser method named after the current mode. Empty content will be ignored. The lexer has a parser handler for each mode in the lexer. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$content} & Text parsed. \\
\hline
boolean & {\em \$is\_\-match} & Token is recognised rather than unparsed data.  private \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_a681e5891f263a352e8502f8196b541fc}{
\index{SimpleLexer@{SimpleLexer}!\_\-isModeEnd@{\_\-isModeEnd}}
\index{\_\-isModeEnd@{\_\-isModeEnd}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-isModeEnd}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-isModeEnd (
\begin{DoxyParamCaption}
\item[{\$}]{ mode}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a681e5891f263a352e8502f8196b541fc}
Tests to see if the new mode is actually to leave the current mode and pop an item from the matching mode stack. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$mode} & Mode to test. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean True if this is the exit mode.  private 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_a419cf4b1b734f60af7a867f352decbd1}{
\index{SimpleLexer@{SimpleLexer}!\_\-isSpecialMode@{\_\-isSpecialMode}}
\index{\_\-isSpecialMode@{\_\-isSpecialMode}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-isSpecialMode}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-isSpecialMode (
\begin{DoxyParamCaption}
\item[{\$}]{ mode}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a419cf4b1b734f60af7a867f352decbd1}
Test to see if the mode is one where this mode is entered for this token only and automatically leaves immediately afterwoods. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$mode} & Mode to test. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean True if this is the exit mode.  private 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_a7d11e9e2b45a5b585b57f82e760b5454}{
\index{SimpleLexer@{SimpleLexer}!\_\-reduce@{\_\-reduce}}
\index{\_\-reduce@{\_\-reduce}!SimpleLexer@{SimpleLexer}}
\subsubsection[{\_\-reduce}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::\_\-reduce (
\begin{DoxyParamCaption}
\item[{\$}]{ raw}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a7d11e9e2b45a5b585b57f82e760b5454}
Tries to match a chunk of text and if successful removes the recognised chunk and any leading unparsed data. Empty strings will not be matched. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$raw} & The subject to parse. This is the content that will be eaten. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
array/boolean Three item list of unparsed content followed by the recognised token and finally the action the parser is to take. True if no match, false if there is a parsing error.  private 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_a4fd4c1124a0c5f7b16548351779deab7}{
\index{SimpleLexer@{SimpleLexer}!addEntryPattern@{addEntryPattern}}
\index{addEntryPattern@{addEntryPattern}!SimpleLexer@{SimpleLexer}}
\subsubsection[{addEntryPattern}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::addEntryPattern (
\begin{DoxyParamCaption}
\item[{\$}]{ pattern, }
\item[{\$}]{ mode, }
\item[{\$}]{ new\_\-mode}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a4fd4c1124a0c5f7b16548351779deab7}
Adds a pattern that will enter a new parsing mode. Useful for entering parenthesis, strings, tags, etc. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$pattern} & Perl style regex, but ( and ) lose the usual meaning. \\
\hline
string & {\em \$mode} & Should only apply this pattern when dealing with this type of input. \\
\hline
string & {\em \$new\_\-mode} & Change parsing to this new nested mode.  public \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_a1cf1b9bc0c1d4b8b3dd465e31a6e1a15}{
\index{SimpleLexer@{SimpleLexer}!addExitPattern@{addExitPattern}}
\index{addExitPattern@{addExitPattern}!SimpleLexer@{SimpleLexer}}
\subsubsection[{addExitPattern}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::addExitPattern (
\begin{DoxyParamCaption}
\item[{\$}]{ pattern, }
\item[{\$}]{ mode}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a1cf1b9bc0c1d4b8b3dd465e31a6e1a15}
Adds a pattern that will exit the current mode and re-\/enter the previous one. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$pattern} & Perl style regex, but ( and ) lose the usual meaning. \\
\hline
string & {\em \$mode} & Mode to leave.  public \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_af0ef334972904054720c4ededafb9a24}{
\index{SimpleLexer@{SimpleLexer}!addPattern@{addPattern}}
\index{addPattern@{addPattern}!SimpleLexer@{SimpleLexer}}
\subsubsection[{addPattern}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::addPattern (
\begin{DoxyParamCaption}
\item[{\$}]{ pattern, }
\item[{\$}]{ mode = {\ttfamily \char`\"{}accept\char`\"{}}}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_af0ef334972904054720c4ededafb9a24}
Adds a token search pattern for a particular parsing mode. The pattern does not change the current mode. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$pattern} & Perl style regex, but ( and ) lose the usual meaning. \\
\hline
string & {\em \$mode} & Should only apply this pattern when dealing with this type of input.  public \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_a59d5052dc25de99c53042847e8214c4f}{
\index{SimpleLexer@{SimpleLexer}!addSpecialPattern@{addSpecialPattern}}
\index{addSpecialPattern@{addSpecialPattern}!SimpleLexer@{SimpleLexer}}
\subsubsection[{addSpecialPattern}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::addSpecialPattern (
\begin{DoxyParamCaption}
\item[{\$}]{ pattern, }
\item[{\$}]{ mode, }
\item[{\$}]{ special}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_a59d5052dc25de99c53042847e8214c4f}
Adds a pattern that has a special mode. Acts as an entry and exit pattern in one go, effectively calling a special parser handler for this token only. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$pattern} & Perl style regex, but ( and ) lose the usual meaning. \\
\hline
string & {\em \$mode} & Should only apply this pattern when dealing with this type of input. \\
\hline
string & {\em \$special} & Use this mode for this one token.  public \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_ad84116197560273d3fd02bd5e74dfe81}{
\index{SimpleLexer@{SimpleLexer}!mapHandler@{mapHandler}}
\index{mapHandler@{mapHandler}!SimpleLexer@{SimpleLexer}}
\subsubsection[{mapHandler}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::mapHandler (
\begin{DoxyParamCaption}
\item[{\$}]{ mode, }
\item[{\$}]{ handler}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_ad84116197560273d3fd02bd5e74dfe81}
Adds a mapping from a mode to another handler. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$mode} & Mode to be remapped. \\
\hline
string & {\em \$handler} & New target handler.  public \\
\hline
\end{DoxyParams}
\hypertarget{class_simple_lexer_afeceabe5e976b20b1e14fed952d79107}{
\index{SimpleLexer@{SimpleLexer}!parse@{parse}}
\index{parse@{parse}!SimpleLexer@{SimpleLexer}}
\subsubsection[{parse}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::parse (
\begin{DoxyParamCaption}
\item[{\$}]{ raw}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_afeceabe5e976b20b1e14fed952d79107}
Splits the page text into tokens. Will fail if the handlers report an error or if no content is consumed. If successful then each unparsed and parsed token invokes a call to the held listener. 
\begin{DoxyParams}[1]{Parameters}
string & {\em \$raw} & Raw HTML text. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean True on success, else false.  public 
\end{DoxyReturn}
\hypertarget{class_simple_lexer_ae2bb586444d1d4ce1ef521b9f6b2bc75}{
\index{SimpleLexer@{SimpleLexer}!SimpleLexer@{SimpleLexer}}
\index{SimpleLexer@{SimpleLexer}!SimpleLexer@{SimpleLexer}}
\subsubsection[{SimpleLexer}]{\setlength{\rightskip}{0pt plus 5cm}SimpleLexer::SimpleLexer (
\begin{DoxyParamCaption}
\item[{\&\$}]{ parser, }
\item[{\$}]{ start = {\ttfamily \char`\"{}accept\char`\"{}}, }
\item[{\$}]{ case = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{class_simple_lexer_ae2bb586444d1d4ce1ef521b9f6b2bc75}
Sets up the lexer in case insensitive matching by default. 
\begin{DoxyParams}[1]{Parameters}
SimpleSaxParser & {\em \$parser} & Handling strategy by reference. \\
\hline
string & {\em \$start} & Starting handler. \\
\hline
boolean & {\em \$case} & True for case sensitive.  public \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
/Volumes/Users/Entwicklung/php/workspace\_\-koala\_\-3/koala-\/core/classes/PHPsTeam/unittest/classes/parser.php\end{DoxyCompactItemize}
